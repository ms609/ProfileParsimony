library(memoise)
ICPerStep <- function(splits, max.iter) ICS(min(splits), max(splits), max.iter)
ICS <- memoize(function(a, b, m) ICSteps(c(rep(1, a), rep(2, b)), max.iter=m))

## phangorn::phyDat has inexplicably stopped working.  Try to fix it.
## For simplicity I have not retained support for contrast matrices or ambiguity.
PhyDat <- function (data, levels = NULL, compress = TRUE, ...) {
  if (is.null(levels)) stop("Levels not supplied")
  nam <- names(data)
  # data <- as.data.frame(t(data), stringsAsFactors = FALSE)
  if (length(data[[1]]) == 1) {
      compress <- FALSE
  }
  if (compress) {
    ddd    <- phangorn:::fast.table(data)
    data   <- ddd$data
    weight <- ddd$weight
    index  <- ddd$index
    n.rows <- length(data[[1]])
  } else {
    n.rows <- length(data[[1]])
    weight <- rep(1, n.rows)
    index <- 1:n.rows
  }
  n.levels <- length(levels)
  contrast <- diag(n.levels)
  all.levels <- levels
  att <- attributes(data)
  data <- lapply(data, match, all.levels)
  attributes(data) <- att
  row.names(data) <- as.character(1:n.rows)
  data <- na.omit(data)
  tmp  <- match(index, attr(data, "na.action"))
  index <- index[is.na(tmp)]
  index <- match(index, unique(index))
  rn <- as.numeric(rownames(data))
  attr(data, "na.action") <- NULL
  weight <- weight[rn]
  n.rows <- dim(data)[1]
  names(data) <- nam
  attr(data, "row.names") <- NULL
  attr(data, "weight")    <- weight
  attr(data, "nr")        <- n.rows
  attr(data, "nc")        <- length(levels)
  attr(data, "index")     <- index
  attr(data, "levels")    <- levels
  attr(data, "allLevels") <- all.levels
  attr(data, "type")      <- "USER"
  attr(data, "contrast")  <- contrast
  class(data)             <- "phyDat"
  data
}

Min <- function (x, inapp.level) {
  if (length(inapp.level)) return(sum(2^(c(0:(inapp.level-2), inapp.level:12)) %in% unique(x)))
  return (sum(2^(0:12) %in% unique(x)))
}

PrepareDataFitch <- function (data) {
# Written with reference to phangorn:::prepareDataFitch
  at <- attributes(data)
  nam <- at$names
  nLevel <- length(at$level)
  nChar <- at$nr
  cont <- attr(data, "contrast")
  nTip <- length(data)
  info.amounts <- InfoAmounts(data)
  max.length <- max(vapply(info.amounts, length, integer(1)))
  info <- array(0, dim=c(nChar, max.length))
  for (i in 1:nChar) info[i, 1:length(info.amounts[[i]])] <- info.amounts[[i]]
  at$names <- NULL
  powers.of.2 <- 2L ^ c(0L:(nLevel - 1L))
  tmp <- cont %*% powers.of.2
  tmp <- as.integer(tmp)
  data <- unlist(data, FALSE, FALSE)
  ret <- tmp[data] 
  ret <- as.integer(ret)
  attributes(ret) <- at
  inapp.level <- which(at$levels == "-")
  attr(ret, 'inapp.level') <- 2 ^ (inapp.level - 1)
  attr(ret, 'dim') <- c(nChar, nTip)  
  attr(ret, 'unique.tokens') <- apply(ret, 1, function(x) Min(x, inapp.level))
  applicable.tokens <- setdiff(powers.of.2, 2 ^ (inapp.level - 1))
  attr(ret, 'split.sizes') <- apply(ret, 1, function(x) vapply(applicable.tokens, function (y) sum(x == y), integer(1)))
  attr(ret, 'info.amounts') <- info
  dimnames(ret) <- list(NULL, nam)
  class(ret) <- 'fitchDat'
  ret
}

InfoAmounts <- function (data) {
  # The below is simplified from info_extra_step.r::evaluate
  chars  <- matrix(unlist(data), attr(data, 'nr'))
  splits <- apply(chars, 1, table)  # No ambiguous tokens to worry about
  info.losses <- apply(splits, 2, ICPerStep, max.iter=10000)  ## TODO increase to 100000
  ret <- lapply(info.losses, function(p) {
    cump <- cumsum(p)
    n.steps <- as.integer(names(p))
    infer <- min(n.steps):max(n.steps)
    infer <- infer[!(infer %in% n.steps)]
    calculated.p <- double(max(n.steps))
    calculated.p[n.steps] <- cump
    if (length(infer)) {
      fitL <- nls(cump ~ SSlogis(n.steps, Asym, xmid, scal))
      calculated.p[infer] <- LogisticPoints(infer, fitL)
      warning('Concavity function generated by approximation')
    }
    calc.ic <- -log(calculated.p) / log(2)
    calc.ic
  })
  ret
}

Suboptimality <- function (trees) {
  scores <- vapply(trees, attr, double(1), 'score')
  return(scores - min(scores))
}

Pratchet <- function (tree, data, all=FALSE, outgroup=NULL, pratchiter=100, searchiter=5000,
                      searchhits=40, k=10, track=0, rearrangements="NNI", suboptimal=0, ...) {
  if (class(data) == 'phyDat') data <- PrepareDataFitch(data)
  if (class(data) != 'fitchDat') stop("data must be a phyDat object, or the output of PrepareDataFitch(phyDat object).")
  epsilon <- 1e-08
  if (is.null(attr(tree, "score"))) attr(tree, "score") <- FitchInfoFast(tree, data)
  best.score <- attr(tree, "score")
  if (track >= 0) cat("\n* Initial score:", best.score)
  if (all) {
    null.forest <- vector('list', pratchiter)
    forest <- null.forest
    forest.scores <- double(pratchiter)
  }

  kmax <- 0
  for (i in 1:pratchiter) {
    if (track >= 0) cat ("\n - Running NNI on bootstrapped dataset. ")
    bstree <- Bootstrap(phy=tree, x=data, maxiter=searchiter, maxhits=searchhits, track=track - 1, ...)
    
    if (track >= 0) cat ("\n - Running", ifelse(is.null(rearrangements), "NNI", rearrangements), "from new candidate tree:")
    if (rearrangements == "TBR") {
      candidate <- TreeSearch(bstree,    data, method='TBR', track=track, maxiter=searchiter, maxhits=searchhits, ...)
      candidate <- TreeSearch(candidate, data, method='SPR', track=track, maxiter=searchiter, maxhits=searchhits, ...)
      candidate <- TreeSearch(candidate, data, method='NNI', track=track, maxiter=searchiter, maxhits=searchhits, ...)
    } else if (rearrangements == "TBR only") {  
      candidate <- TreeSearch(bstree,    data, method='TBR', track=track, maxiter=searchiter, maxhits=searchhits, ...)
    } else if (rearrangements == "SPR") {       
      candidate <- TreeSearch(bstree,    data, method='SPR', track=track, maxiter=searchiter, maxhits=searchhits, ...)
      candidate <- TreeSearch(candidate, data, method='NNI', track=track, maxiter=searchiter, maxhits=searchhits, ...)
    } else if (rearrangements == "SPR only") {  
      candidate <- TreeSearch(bstree,    data, method='SPR', track=track, maxiter=searchiter, maxhits=searchhits, ...)
    } else {                                    
      candidate <- TreeSearch(bstree,    data, method='NNI', track=track, maxiter=searchiter, maxhits=searchhits, ...)
    }
    cand.score <- attr(candidate, 'score')
    if ((cand.score + epsilon) < best.score) {
      # New 'best' tree
      if (all) {
        forest[[i]] <- if (is.null(outgroup)) candidate else Root(candidate, outgroup)
        forest.scores[i] <- cand.score
      }
      tree <- candidate
      best.score <- cand.score
      kmax <- 1
    } else if (best.score + epsilon > cand.score) { # i.e. best == cand, allowing for floating point error
      kmax <- kmax + 1
      tree <- candidate
      if (all) {
        forest[[i]] <- if (is.null(outgroup)) candidate else Root(candidate, outgroup)
        forest.scores[i] <- cand.score
      }
    } else if (cand.score < (best.score + suboptimal) && all) {
      forest[[i]] <- if (is.null(outgroup)) candidate else Root(candidate, outgroup)
      forest.scores[i] <- cand.score
    }
    if (track >= 0) cat("\n* Best score after", i, "/", pratchiter, "pratchet iterations:", best.score, "( hit", kmax, "/", k, ")")
    if (kmax >= k) break()
  } # end for
  if (track >= 0) cat ("\nCompleted parsimony ratchet with score", best.score, "\n")
    
  if (all) {
    keepers <- forest.scores < best.score + suboptimal
    forest.scores <- forest.scores[keepers]
    forest <- forest[keepers]
    class(forest) <- 'multiPhylo'
    duplicated(forest)
    ret <- unique(forest)
    scores.unique <- vapply(ret, attr, double(1), 'score')
    cat('Found', sum(scores.unique == min(scores.unique)), 'unique MPTs and', length(ret) - sum(scores.unique == min(scores.unique)), 'suboptimal trees.')
    if (is.null(outgroup)) warning('"outgroup" not specified, so some "unique" trees may have same topology but distinct roots.')
  } else {
    ret <- tree
    attr(ret, 'hits') <- NULL
  }
  return (ret)
}
  
Bootstrap <- function (phy, x, maxiter, maxhits, track=1, ...) {
## Simplified version of phangorn::bootstrap.phyDat, with bs=1 and multicore=FALSE
  at <- attributes(x)
  weight <- at$weight
  v <- rep(1:length(weight), weight)
  BS <- tabulate(sample(v, replace=TRUE), length(weight)) 
  keep <- BS > 0
  ind <- which(keep)
  x <- x[ind, ]
  attr(x, 'weight') <- BS[ind]
  attr(x, 'min.steps') <- at$min.steps[keep]
  attr(x, 'info.amounts') <- at$info.amounts[keep, ]
  attr(x, 'unique.tokens') <- at$unique.tokens[keep]
  attr(x, 'nr') <- length(ind)
  attr(x, 'inapp.level') <- at$inapp.level
  attr(phy, 'score') <- NULL
  class(x) <- 'fitchDat'
  res <- TreeSearch(phy, x, method='NNI', maxiter=maxiter, maxhits=maxhits, track=track-1, ...)
  attr(res, 'score') <- NULL
  attr(res, 'hits') <- NULL
  res
}

TreeSearch <- function (tree, data, method='NNI', maxiter=100, maxhits=20, forest.size=1,
                        cluster=NULL, track=1, ...) {
  tree$edge.length <- NULL # Edge lengths are not supported
  attr(tree, 'hits') <- 1
  if (exists("forest.size") && length(forest.size) && forest.size > 1) {
    forest <- empty.forest <- vector('list', forest.size)
    forest[[1]] <- tree
  } else {
    forest.size <- 1 
  }
  if (is.null(attr(tree, 'score'))) attr(tree, 'score') <- FitchInfoFast(tree, data)
  best.score <- attr(tree, 'score')
  if (track > 0) cat("\n  - Performing", method, "search.  Initial score:", best.score)
  rearrange.func <- switch(method, 'TBR' = TBR, 'SPR' = SPR, 'NNI' = QuickNNI)
  return.single <- !(forest.size > 1)
  
  for (iter in 1:maxiter) {
    trees <- RearrangeTree(tree, data, rearrange.func, min.score=best.score, return.single=return.single, iter=iter, cluster=cluster, track=track)
    iter.score <- attr(trees, 'score')
    if (length(forest.size) && forest.size > 1) {
      hits <- attr(trees, 'hits')
      if (iter.score == best.score) {
        forest[(hits-length(trees)+1L):hits] <- trees
        tree <- sample(forest[1:hits], 1)[[1]]
        attr(tree, 'score') <- iter.score
        attr(tree, 'hits') <- hits
      } else if (iter.score < best.score) {
        best.score <- iter.score
        forest <- empty.forest
        forest[1:hits] <- trees
        tree <- sample(trees, 1)[[1]]
        attr(tree, 'score') <- iter.score
        attr(tree, 'hits') <- hits
      }      
    } else {
      if (iter.score <= best.score) {
        best.score <- iter.score
        tree <- trees
      }
    }
    if (attr(trees, 'hits') >= maxhits) break
  }
  if (track > 0) cat("\n  - Final score", attr(tree, 'score'), "found", attr(tree, 'hits'), "times after", iter, method, "iterations\n")  
  if (forest.size > 1) {
    if (hits < forest.size) forest <- forest[-((hits+1):forest.size)]
    attr(forest, 'hits') <- hits
    attr(forest, 'score') <- best.score
    return(unique(forest))
  } else {
    return(tree)
  }
}

RearrangeTree <- function (tree, data, rearrange, min.score=NULL, return.single=TRUE,
                           iter='<unknown>', cluster=NULL, track=0) {
  if (is.null(attr(tree, 'score'))) best.score <- 1e+07 else best.score <- attr(tree, 'score')
  if (is.null(attr(tree, 'hits'))) hits <- 1 else hits <- attr(tree, 'hits')
  if (is.null(cluster)) {
    re.tree <- rearrange(tree)
    trees <- list(re.tree)
    min.score <- FitchInfoFast(re.tree, data)
    best.trees <- c(TRUE)
  } else {
    #candidates <- clusterCall(cluster, function(re, tr, k) {ret <- re(tr); attr(ret, 'score') <- FitchInfoFast(ret, cl.data, k); ret}, rearrange, tree)
    #scores <- vapply(candidates, function(x) attr(x, 'ps'), 1)
    candidates <- clusterCall(cluster, rearrange, tree)
    scores <- vapply(candidates, FitchInfoFast, 1, data, target=min.score) # ~3x faster to do this in serial in r233.
    min.score <- min(scores)
    best.trees <- scores == min.score
    trees <- candidates[best.trees]
  }
  if (best.score < min.score) {
    if (track > 3) cat("\n    . Iteration", iter, '- Min score', min.score, ">", best.score)
  } else if (best.score == min.score) {
    hits <- hits + sum(best.trees)
    if (track > 2) cat("\n    - Iteration", iter, "- Best score", min.score, "hit", hits, "times")
  } else {
    hits <- sum(best.trees)
    if (track > 1) cat("\n    * Iteration", iter, "- New best score", min.score, "found on", hits, "trees")
  }
  if (length(return.single) && return.single) trees <- sample(trees, 1)[[1]]
  attr(trees, 'hits') <- hits
  attr(trees, 'score') <- min.score
  trees
}

QuickNNI <- function (tree) {
  n      <- sample(tree$Nnode - 1L, 1L)
  edge   <- tree$edge
  parent <- edge[, 1L]
  child  <- edge[, 2L]
  k      <- min(parent) - 1L
  ind    <- which(child > k)[n]
  p1     <- parent[ind]
  p2     <- child[ind]
  ind1   <- which(parent == p1)
  ind1   <- ind1[ind1 != ind][1L]
  ind2   <- which(parent == p2)[sample(2L,1L)]
  tree$edge[c(ind1, ind2), 2L] <- child[c(ind2, ind1)]
  Renumber(phangorn:::reorderPruning(tree))
}

SPR <- function(tree) {
  tip.label <- tree$tip.label
  nTips <- length(tip.label)
  edge  <- tree$edge; parent <- edge[,1L]; child <- edge[,2L]
  nEdge <- length(child)
  root  <- nTips + 1L
  if (nTips < 4L) stop ('must be >3 tips for SPR rearrangement!')
  pruning.candidates <- seq(nEdge + 1L)[-root]
  repeat {
    prune.node <- sample(pruning.candidates, 1)
    moving.subnodes <- c(prune.node, which(do.descendants(parent, child, nTips, prune.node)))
    moving.nodes <- c(prune.parent <- parent[child==prune.node], moving.subnodes)
    dont.graft.here <- c(moving.nodes, child[parent==prune.parent])
    graft.node <- c(pruning.candidates[!pruning.candidates %in% dont.graft.here])
    if (length(graft.node) > 1) graft.node <- sample(graft.node, 1)
    if (any(graft.node)) break;
    pruning.candidates <- pruning.candidates[-match(prune.node, pruning.candidates)]
    if (!any(pruning.candidates)) stop('No place to graft pruned tree')
  } 
  
  graft.edge   <- match(graft.node, child)
  graft.parent <- parent[graft.edge]
  graft.child  <-  child[graft.edge]
  prune.edge   <- match(prune.node, child)
  parent.duplicate <- parent
  parent.duplicate[prune.edge] <- NA
  sister.edge  <- match(prune.parent, parent.duplicate)
  if (prune.parent == root) {
    new.root <- child[parent==root]
    new.root <- new.root[new.root != prune.node]
    edge[sister.edge, 2L] <- edge[graft.edge, 2L]
    edge[graft.edge, 2L] <- root
    new.root.spots <- edge==new.root
    edge[edge == root] <- new.root
    edge[new.root.spots] <- root
  } else {
    leading.edge <- match(prune.parent, child)
    edge[c(leading.edge, sister.edge, graft.edge), 2] <- edge[c(sister.edge, graft.edge, leading.edge), 2]
  }
  
  reordered.edge <- .C('order_edges', as.integer(edge[,1]), as.integer(edge[,2]), as.integer(nTips-1L), as.integer(nEdge), PACKAGE='inapplicable')
  numbered.edge <- .C('number_nodes', as.integer(reordered.edge[[1]]), as.integer(reordered.edge[[2]]), as.integer(root), as.integer(nEdge), PACKAGE='inapplicable')
  tree$edge <- matrix(c(numbered.edge[[1]], numbered.edge[[2]]), ncol=2)
  tree
}

TBR <- function(tree, edge.to.break=NULL) {
  nTips <- tree$Nnode + 1
  if (nTips < 3) return (tree)
  tree.edge <- tree$edge
  tree.parent <- tree.edge[,1]
  tree.child <- tree.edge[,2]
  if (nTips == 3) return (Root(tree, sample(tree.child[tree.parent==max(tree.parent)], 1L)))
  all.nodes <- 1:(2*(nTips-1))
  root <- nTips + 1
  if (is.null(edge.to.break)) edge.to.break <- sample(2L:nrow(tree.edge), 1L) # Only include one root edge
  subtree.root <- tree.child[edge.to.break]
  #cat("\n - ", edge.to.break, subtree.root)
  stump <- if (subtree.root <= nTips) {
    DropTipNoSubtree(tree, subtree.root, root.edge=1)
  } else {
    in.crown <- do.descendants(tree.parent, tree.child, nTips, subtree.root, just.tips=TRUE)
    DropTipNoSubtree(tree, which(in.crown), root.edge=1)
  }
  stump.len <- dim(stump$edge)[1]
  crown <- ExtractClade(tree, subtree.root) # ~ 2x faster than DropTip
  crown.edge <- crown$edge
  crown.len <- dim(crown.edge)[1]  
  if (crown.len > 1) {
    if (crown.len == 2) {
      rerooted.crown <- crown
    } else {
      crown.parent <- crown.edge[,1]
      crown.child <- crown.edge[,2]
      crown.nNode <- crown$Nnode
      crown.tips <- crown.nNode + 1L
      crown.root <- min(crown.parent)
      new.root.candidates <- crown.child[-1] # Include existing root once only
      new.root.node <- sample(new.root.candidates, 1L)
      if (new.root.node <= crown.tips) new.outgroup <- new.root.node else new.outgroup <- which(do.descendants(crown.parent, crown.child, crown.tips, new.root.node, just.tips=TRUE))
      rerooted.crown <- Root(crown, new.outgroup)
    }
    rerooted.crown$root.edge <- 1L
    if (stump.len > 1) {
      bind.location <- sample(seq_len(stump.len), 1L)
      ret <- BindTree(stump, rerooted.crown, position=1, where=bind.location)
    } else {
      ret <- AddTip(rerooted.crown, crown.root, stump$tip.label)
    }
  } else {
    bind.location <- stump$edge[sample(2L:stump.len, 1L), 2L]
    ret <- AddTip(stump, bind.location, crown$tip.label)
  }
  Renumber(ret)
}

DropTipNoSubtree <- function(phy, tip, root.edge = 0, rooted = is.rooted(phy)) {
# Copied from ape:::drop.tip; edited to avoid excessive calls to $, and to support single-taxon trees.
# Dropped support for branch lengths.
# Dropped checks and warnings: assumed that data passed to this function is good!
# Hard-coded subtree = FALSE and trim.internal = TRUE
  if (!length(tip)) return(phy)
  phy.edge <- phy$edge
  phy.tip <- phy$tip.label
  n.tip <- length(phy.tip)
  if (is.character(tip)) {
    tip <- match(tip, phy.tip, nomatch=0)
    tip <- tip[as.logical(tip)]
  }
  ntip.to.drop <- length(tip)
  if (!ntip.to.drop) return(phy)
  if (ntip.to.drop + 1 == n.tip) 
    return(SingleTaxonTree(phy.tip[setdiff(1:n.tip, tip)]))

  phy <- reorder(phy)
  NEWROOT <- ROOT <- n.tip + 1
  Nnode <- phy$Nnode
  edge1 <- phy.edge[, 1] # local copies
  edge2 <- phy.edge[, 2] #
  nEdge <- length(edge1)
  keep <- !logical(nEdge)
  keep[match(tip, edge2)] <- FALSE # Delete the terminal edges given by 'tip'
  ints <- edge2 > n.tip
  ## delete the internal edges that no longer have
  ## descendants (ie, they are in the 2nd col of `edge' but
  ## not in the 1st one)
  repeat {
    sel <- !(edge2 %in% edge1[keep]) & ints & keep
    if (!any(sel)) break
    keep[sel] <- FALSE
  }
  if (!root.edge) phy$root.edge <- NULL
  ## drop the edges
  phy.edge <- phy.edge[keep, ]
  phy.edge2 <- phy.edge[,2L]
  phy.edge1 <- phy.edge[,1L]
  TERMS <- !(phy.edge2 %in% phy.edge1)
  ## get the old No. of the nodes and tips that become tips:
  oldNo.ofNewTips <- phy.edge2[TERMS]
  
  n <- length(oldNo.ofNewTips) # the new number of tips in the tree
  ## the tips may not be sorted in increasing order in the
  ## 2nd col of edge, so no need to reorder $tip.label
  phy.edge2[TERMS] <- rank(oldNo.ofNewTips)
  phy$tip.label <- phy$tip.label[-tip]
  phy$Nnode <- phy.nNode <- length(phy.edge2) - n + 1L # update phy$Nnode
  ## The block below renumbers the nodes so that they conform
  ## to the "phylo" format, same as in root()
  newNb <- integer(n.tip + Nnode)
  newNb[NEWROOT] <- n + 1L
  sndcol <- phy.edge2 > n
  ## executed from right to left, so newNb is modified before phy.edge:
  phy.edge2[sndcol] <- newNb[phy.edge2[sndcol]] <-
      (n + 2):(n + phy.nNode)
  phy.edge1 <- newNb[phy.edge1]
  phy$edge <- matrix(c(phy.edge1, phy.edge2), ncol=2)
  storage.mode(phy$edge) <- "integer"
  if (!is.null(phy$node.label)) # update node.label if needed
      phy$node.label <- phy$node.label[which(newNb > 0) - n.tip]
  CollapseSingles(phy)
}

CollapseSingles <- function (tree) {
# Copied from ape:::collapse.singles.
# Removed support for elen & node.label to improve performance
  xmat <- tree$edge
  nnode <- tree$Nnode
  ntip <- length(tree$tip.label)
  repeat {
    tx <- tabulate(xmat[, 1L])
    singles <- match(tx, 1L, nomatch=0)
    if (!any(singles)) break;
    first.single <- which.max(singles)
    next.node <- which.max(match.single <- match(xmat, first.single))
    match.single[next.node] <- NA
    prev.node <- which.max(match.single) - (nnode <- nnode - 1L) - ntip
    xmat[prev.node, 2L] <- xmat[next.node, 2L]
    xmat <- xmat[-next.node,]
    xmat[xmat > first.single] <- xmat[xmat > first.single] - 1L
  }
  tree$edge <- xmat
  tree$Nnode <- nnode
  tree
}

SingleTaxonTree <- function (label) {
  res <- list(edge=matrix(c(2L, 1L), 1, 2), tip.label=label, Nnode=1L)
  class(res) <- 'phylo'
  res
}

ExtractClade <- function (phy, node) {
  phy.tip.label <- phy$tip.label
  phy.edge <- phy$edge
  phy.child <- phy.edge[,2L]
  nTip <- length(phy.tip.label)
  if (node <= nTip) return(SingleTaxonTree(phy.tip.label[node]))
  if (node == nTip + 1L) return(phy)
  nodes.to.keep <- DoDescendants(phy.edge[,1L], phy.child, nTip, node)
  edges.to.keep <- phy.child %in% which(nodes.to.keep)
  phy.edge <- phy.edge[edges.to.keep, ]

  phy.edge1 <- phy.edge[,1L]
  phy.edge2 <- phy.edge[,2L]
  TIPS <- phy.edge2 <= nTip
  tip <- phy.edge2[TIPS]
  name <- vector("character", length(tip))
  name[order(tip)] <- phy.tip.label[tip]
  phy$tip.label <- name
  new.nTip <- length(name)
  phy.edge2[TIPS] <- order(tip)
  
  ## Renumber nodes:
  phy.edge2[!TIPS] <- (phy.edge2[!TIPS] - node) + new.nTip + 1L
  phy.edge1 <- (phy.edge1 - node) + new.nTip + 1L
  phy$Nnode <- dim(phy.edge)[1] - new.nTip + 1L
  phy.edge[,1] <- phy.edge1;  phy.edge[,2] <- phy.edge2
  phy$edge <- phy.edge
  
  phy
}

Root <- function (tree, outgroup) {
  if (class(tree) != 'phylo') stop ('"tree" must be of class "phylo"')
  tip <- tree$tip.label
  if (is.character(outgroup)) {outgroup <- match(outgroup, tip, nomatch=0); outgroup <- outgroup[as.logical(outgroup)]}
  if (length(outgroup) < 1) stop ('"outgroup" not specified')
  if (!is.null(tree$edge.length)) {tree$edge.length <- NULL; warning('Edge lengths are not supported and have been dropped.')}
  nTips <- length(tip)
  edge <- tree$edge
  parent <- edge[,1]
  child <- edge[,2]
  root <- min(parent)
  root.children <- child[parent==root]
  rooted.on.ingroup <- FALSE
  # Check that outgroup is currently monophyletic, swapping with 'ingroup' if it's not
  repeat { 
    ancestry <- Ancestors(parent, child, outgroup)
    if (length(outgroup) > 1) {
      common.ancestors <- Reduce(intersect, ancestry)
      outgroup.root.node <- max(common.ancestors)
    } else {
      common.ancestors <- c(outgroup, ancestry)
      outgroup.root.node <- outgroup
    }
    if (outgroup.root.node != root) break
    if (rooted.on.ingroup) stop ('Cannot root tree: polyphyletic outgroup straddles root')
    outgroup <- seq_along(tip)[-outgroup] # outgroup straddles root; root on ingroup instead
    rooted.on.ingroup <- TRUE
  }
 
  visit.node.forwards <- function (old.tree.node, parent.number, new.edges) {
    blank.edge <- which.min(new.edges) # number of first as-yet-unspecified edge
    if (old.tree.node <= nTips) { # Adding a tip
      new.edges[blank.edge, ] <- c(parent.number, old.tree.node)
    } else { # Adding a node
      this.node.new.number <- max(c(nTips + 1, new.edges[, 2])) + 1
      new.edges[blank.edge, ] <- c(parent.number, this.node.new.number)    
      descendant.nodes <- do.descendants(parent, child, nTips, old.tree.node)
      n.new.nodes <- sum(descendant.nodes)
      fill.edge.index <- blank.edge + (1:n.new.nodes)
      fill.edge <- edge[child %in% which(descendant.nodes), ]
      node.spots <- fill.edge > nTips
      fill.edge[node.spots] <- fill.edge[node.spots] + this.node.new.number - old.tree.node
      new.edges[fill.edge.index, ] <- fill.edge
    }
    new.edges
  }
  visit.node.backwards <- function (arrival.edge, last.node.number, new.edges) {
    previous.node <- child[arrival.edge]
    this.node <- parent[arrival.edge]
    forward.node <- child[parent==this.node]
    forward.node <- forward.node[forward.node != previous.node]
    blank.edge <- which.min(new.edges) # First edge left blank after visit.node.forwards
    this.node.new.number <- max(c(nTips + 1L, new.edges[,2L])) + 1L
    if (this.node != root) {
      new.edges[blank.edge, ] <- c(last.node.number, this.node.new.number)
      if (length(forward.node) > 0) {
        for (fwd in forward.node) {
          new.edges <- visit.node.forwards(fwd, this.node.new.number, new.edges)
        }
      }
    } else { # Root edge; don't create a new node
      if (length(forward.node) > 0) {
        for (fwd in forward.node) {
          new.edges <- visit.node.forwards(fwd, last.node.number, new.edges)
        }
      }
    }
    backward.edge <- child.index[this.node]
#   cat("\n, this.node", this.node, "backward.edge", backward.edge, "match", match(this.node, child))  # For debugging only
#   arrival.edge <- backward.edge; last.node.number <- this.node.new.number              # For debugging only
    if (!is.na(backward.edge)) new.edges <- visit.node.backwards(backward.edge, this.node.new.number, new.edges)
    new.edges
  }
  
  last.edge <- length(parent)
  child.index <- order(c(child, root))
  child.index[root] <- NA
  new.edges <- matrix(0, last.edge, 2)
  new.edges <- visit.node.forwards(outgroup.root.node, root, new.edges)
  arrival.edge <- child.index[outgroup.root.node]; last.node.number <- root # For debugging only - DELETE
  new.edges <- visit.node.backwards(child.index[outgroup.root.node], root, new.edges)
  tree$edge <- new.edges
  tree
}

Ancestors <- function (parent, child, node) {
  if (length(node) == 1) {
    pvector <- numeric(max(parent))
    pvector[child] <- parent
    anc <- function(pvector, node) {
      res <- numeric(0)
      repeat {
        anc <- pvector[node]
        if (anc == 0) 
            break
        res <- c(res, anc)
        node <- anc
      }
      res
    }
    return(anc(pvector, node))
  } else AllAncestors(parent, child)[node]
}

AllAncestors <- function (parent, child) {
  res <- vector("list", max(parent))
  for (i in seq_along(parent)) {
    pa <- parent[i]
    res[[child[i]]] <- c(pa, res[[pa]])
  }
  res
}

Descendants <- function (tree, node, ...) {
# ARGUMENTS:
#   "tree", a phydat object
#   "node", number of an internal node
#   "just.tips", should return value include all nodes or just tips?
# RETURN:
#   vector containing descendant nodes in numerical order
  nTip <- length(tree$tip.label)
  edge <- tree$edge
  edge1 <- edge[,1]
  edge2 <- edge[,2]
  return (which(DoDescendants(edge1, edge2, nTip, node, ...)))
}

DoDescendants <- function (edge1, edge2, nTip, node, just.tips = FALSE, just.internal=FALSE,
                           include.ancestor = FALSE) {
  # ARGUMENTS:
  #   "edge1", parent nodes: from tree$edge[,1]
  #   "edge2", parent nodes: from tree$edge[,2]
  #   "node", number of an internal node
  #   "just.tips", should return value include all nodes or just tips?
  # RETURN:
  #   vector containing descendant nodes in numerical order
  is.descendant <- blank <- logical((nTip * 2) - 1)
  if (include.ancestor) is.descendant[node] <- TRUE;
  node.children <- function (node, is.descendant) {
    nc <- edge2[edge1 %in% node]
    is.descendant[nc] <- TRUE
    if (length(nc)) is.descendant <- node.children(nc, is.descendant)
    is.descendant
  }
  is.descendant <- node.children(node, is.descendant)
  if (just.tips) return (is.descendant[1:nTip]) else if (just.internal) is.descendant[1:nTip] <- FALSE 
  return (is.descendant)
}

AddTip <- function (tree, where, label) {
  nTip <- length(tree$tip.label)
  nNode <- tree$Nnode
  ROOT <- nTip + 1L
  if (where < 1L) where <- ROOT
  new.tip.number <- nTip + 1L
  tree.edge <- tree$edge
  
  ## find the row of 'where' before renumbering
  if (where == ROOT) case <- 1 else {
      insertion.edge <- which(tree.edge[, 2] == where)
      case <- if (where <= nTip) 2 else 3
  }
  ## case = 1 -> y is bound on the root of x
  ## case = 2 -> y is bound on a tip of x
  ## case = 3 -> y is bound on a node of x

### because in all situations internal nodes need to be
### renumbered, they are changed to negatives first, and
### nodes eventually added will be numbered sequentially
  nodes <- tree.edge > nTip
  tree.edge[nodes] <- -(tree.edge[nodes] - nTip)  # -1, ..., -nTip
  next.node <- -nNode - 1L
  ROOT <- -1L # This may change later
  
  switch(case, { # case = 1 -> y is bound on the root of x
      tree.edge <- rbind(c(next.node, tree.edge[1]), tree.edge, c(next.node, new.tip.number))
      ROOT <- next.node
    }, { # case = 2 -> y is bound on a tip of x
      tree.edge[insertion.edge, 2] <- next.node
      tree.edge <- rbind(tree.edge[1:insertion.edge, ], c(next.node, where), c(next.node, new.tip.number), tree.edge[-(1:insertion.edge), ])
    }, { # case = 3 -> y is bound on a node of x
      tree.edge <- rbind(tree.edge[1:insertion.edge, ], c(next.node, tree.edge[insertion.edge, 2]), tree.edge[-(1:insertion.edge), ])
      tree.edge[insertion.edge, 2] <- next.node
      insertion.edge <- insertion.edge + 1L
      tree.edge <- rbind(tree.edge[1:insertion.edge, ], c(next.node, new.tip.number), tree.edge[-(1:insertion.edge), ])
    }
  )
  tree$tip.label <- c(tree$tip.label, label)
  tree$Nnode <- nNode <- nNode + 1L
  
  ## Renumber nodes:
  new.numbering <- integer(nNode)
  new.numbering[-ROOT] <- new.tip.number + 1L
  second.col.nodes <- tree.edge[, 2] < 0
  ## executed from right to left, so newNb is modified before x$edge:
  tree.edge[second.col.nodes, 2] <- new.numbering[-tree.edge[second.col.nodes, 2]] <- new.tip.number + 2:nNode
  tree.edge[, 1] <- new.numbering[-tree.edge[, 1]]

  tree$edge <- tree.edge
  tree
}

Renumber <- function (tree) {
## Numbers the nodes and tips in a tree to conform with the phylo standards.
  tree   <- reorder(tree, 'postorder')
  edge   <- tree$edge
  nTip   <- length(tree$tip.label)
  parent <- edge[, 1L]
  child  <- edge[, 2L]
  NODES  <- child > nTip
  TIPS   <- !NODES
  nNode  <- sum(NODES) + 1 # Root node has no edge leading to it, so add 1
  
  tip <- child[TIPS]
  name <- vector("character", length(tip))
  name[1:nTip] <- tree$tip.label[tip]
  tree$tip.label <- name
  child[TIPS] <- 1:nTip
  
  old.node.number <- unique(parent)
  new.node.number <- rev(nTip + seq_along(old.node.number))
  renumbering.schema <- integer(nNode)
  renumbering.schema[old.node.number - nTip] <- new.node.number
  child[NODES] <- renumbering.schema[child[NODES] - nTip]
  nodeseq <- (1L:nNode) * 2L
  parent <- renumbering.schema[parent - nTip]
  
  tree$edge[,1] <- parent
  tree$edge[,2] <- child
  reorder(tree)
}

BindTree <- function(x, y, where = "root", position = 0, interactive = FALSE) {
## Copied from ape:::bind.tree; the only change is that I use (x|y).edge in place of (x|y)$edge.

    nx <- length(x$tip.label)
    mx <- x$Nnode
    ROOTx <- nx + 1L
    ny <- length(y$tip.label)
    my <- y$Nnode

    if (interactive) {
        lastPP <- get("last_plot.phylo", envir = .PlotPhyloEnv)
        if (lastPP$type != "phylogram" || lastPP$direction != "rightwards")
            stop("you must plot tree 'x' as a 'rightward phylogram'")
        cat("Click where you want to graft tree 'y'...\n")
        xy <- locator(1)
        d <- abs(xy$y - lastPP$yy)
        d[lastPP$xx - xy$x < 0] <- Inf
        where <- which.min(d)
        position <- lastPP$xx[where] - xy$x
        if (position < 0) position <- 0
        cat("The following parameters are used:\n")
        cat("  where =", where, " position =", position, "\n")
    } else {
        if (where == 0 || where == "root") where <- ROOTx
        if (position < 0) position <- 0
        if (where > nx + mx)
            stop("argument 'where' out of range for tree 'x'")
    }

    ## check whether both trees have branch lengths:
    switch(is.null(x$edge.length) + is.null(y$edge.length) + 1L,
           wbl <- TRUE, {
               x$edge.length <- y$edge.length <- NULL
               wbl <- FALSE
               warning("one tree has no branch lengths, they have been ignored")
           },
           wbl <- FALSE)

    yHasNoRootEdge <- is.null(y$root.edge)
    xHasNoRootEdge <- is.null(x$root.edge)

    x.edge <- x$edge
    y.edge <- y$edge
    ## find the row of 'where' before renumbering
    if (where == ROOTx) case <- 1 else {
        i <- which(x.edge[, 2] == where)
        case <- if (where <= nx) 2 else 3
    }
    ## case = 1 -> y is bound on the root of x
    ## case = 2 -> y is bound on a tip of x
    ## case = 3 -> y is bound on a node of x

    ## check that 'position' is correct
    if (position && wbl) {
### New in ape 3.0-1: this makes possible binding 'y' below
### a node of 'x' thus creating a new node in 'x'
###        if (!wbl)
###            stop("'position' is non-null but trees have no branch lengths")
        if (case == 1) {
            if (xHasNoRootEdge)
                stop("tree 'x' has no root edge")
            if (position > x$root.edge)
                stop("'position' is larger than x's root edge")
        } else {
            if (x$edge.length[i] < position)
                stop("'position' is larger than the branch length")
        }
    }

    ## the special case of substituting two tips:
    if (case == 2 && ny == 1 && !position) {
        x$tip.label[x.edge[i, 2]] <- y$tip.label
        if (wbl)
            x$edge.length[i] <- x$edge.length[i] + y$edge.length
        return(x)
    }

    x <- reorder(x)
    y <- reorder(y)

### because in all situations internal nodes need to be
### renumbered, they are changed to negatives first, and
### nodes eventually added will be numbered sequentially

    nodes <- x.edge > nx
    x.edge[nodes] <- -(x.edge[nodes] - nx) # -1, ..., -mx
    nodes <- y.edge > ny
    y.edge[nodes] <- -(y.edge[nodes] - ny + mx) # -(mx+1), ..., -(mx+my)
    ROOT <- -1L # may change later
    next.node <- -(mx + my) - 1L

    ## renumber now the tips in y:
    new.nx <- if (where <= nx && !position) nx - 1L else nx
    y.edge[!nodes] <- y.edge[!nodes] + new.nx

    ## if 'y' as a root edge, use it:
    if (!yHasNoRootEdge) {
        y.edge <- rbind(c(0, y.edge[1]), y.edge)
        ##                ^ will be filled later
        next.node <- next.node - 1L
        if (wbl) y$edge.length <- c(y$root.edge, y$edge.length)
    }

    switch(case, { # case = 1
        if (position) {
            x$root.edge <- x$root.edge - position
            x.edge <- rbind(c(next.node, x.edge[1]), x.edge)
            ROOT <- next.node
            if (wbl) x$edge.length <- c(position, x$edge.length)
        }
        if (yHasNoRootEdge) {
            j <- which(y.edge[, 1] == y.edge[1])
            y.edge[j, 1] <- ROOT
        } else y.edge[1] <- ROOT
        x.edge <- rbind(x.edge, y.edge)
        if (wbl)
            x$edge.length <- c(x$edge.length, y$edge.length)
    }, { # case = 2
        if (position) {
            x.edge[i, 2] <- next.node
            x.edge <- rbind(x.edge[1:i, ], c(next.node, where), x.edge[-(1:i), ])
            if (wbl) {
                x$edge.length[i] <- x$edge.length[i] - position
                x$edge.length <- c(x$edge.length[1:i], position, x$edge.length[-(1:i)])
            }
            i <- i + 1L
            if (yHasNoRootEdge) {
                j <- which(y.edge[, 1] == y.edge[1])
                y.edge[j, 1] <- x.edge[i, 1]
            } else y.edge[1] <- x.edge[i, 1]
        } else {
            if (yHasNoRootEdge) x.edge[i, 2] <- y.edge[1]
            else {
                ## the root edge of y is fused with the terminal edge of x
                if (wbl) y$edge.length[1] <- y$edge.length[1] + x$edge.length[i]
                y.edge[1] <- x.edge[i, 1]
                ## delete i-th edge in x:
                x.edge <- x.edge[-i, ]
                if (wbl) x$edge.length <- x$edge.length[-i]
                i <- i - 1L
            }
            x$tip.label <- x$tip.label[-where]
            ## renumber the tips that need to:
            ii <- which(x.edge[, 2] > where & x.edge[, 2] <= nx)
            x.edge[ii, 2] <- x.edge[ii, 2] - 1L
        }
        x.edge <- rbind(x.edge[1:i, ], y.edge, x.edge[-(1:i), ])
        if (wbl)
            x$edge.length <- c(x$edge.length[1:i], y$edge.length, x$edge.length[-(1:i)])
    }, { # case = 3
        if (position) {
            if (yHasNoRootEdge) {
                j <- which(y.edge[, 1] == y.edge[1])
                y.edge[j, 1] <- next.node
            } else y.edge[1] <- next.node
            x.edge <- rbind(x.edge[1:i, ], c(next.node, x.edge[i, 2]), x.edge[-(1:i), ])
            x.edge[i, 2] <- next.node
            if (wbl) {
                x$edge.length[i] <- x$edge.length[i] - position
                x$edge.length <- c(x$edge.length[1:i], position, x$edge.length[-(1:i)])
            }
            i <- i + 1L
        } else {
            if (yHasNoRootEdge) {
                j <- which(y.edge[, 1] == y.edge[1])
                y.edge[j, 1] <- x.edge[i, 2]
            } else y.edge[1] <- x.edge[i, 2]
        }
        x.edge <- rbind(x.edge[1:i, ], y.edge, x.edge[-(1:i), ])
        if (wbl)
            x$edge.length <- c(x$edge.length[1:i], y$edge.length, x$edge.length[-(1:i)])
    })

    x$tip.label <- c(x$tip.label, y$tip.label)

    if (is.null(x$node.label)) {
        if (!is.null(y$node.label))
            x$node.label <- c(rep(NA, mx), y$node.label)
    } else {
        x$node.label <-
            if (is.null(y$node.label)) c(x$node.label, rep(NA, my))
            else c(x$node.label, y$node.label)
    }

    n <- length(x$tip.label)
    x$Nnode <- dim(x.edge)[1] + 1L - n

    ## update the node labels before renumbering (this adds NA for
    ## the added nodes, and drops the label for those deleted)
    if (!is.null(x$node.label))
        x$node.label <- x$node.label[sort(-unique(x.edge[, 1]))]

    ## renumber nodes:
    newNb <- integer(x$Nnode)
    newNb[-ROOT] <- n + 1L
    sndcol <- x.edge[, 2] < 0
    ## executed from right to left, so newNb is modified before x.edge:
    x.edge[sndcol, 2] <- newNb[-x.edge[sndcol, 2]] <- n + 2:x$Nnode
    x.edge[, 1] <- newNb[-x.edge[, 1]]
    x$edge <- x.edge
    if (!is.null(x$node.label))
        x$node.label <- x$node.label[order(newNb[newNb > 0])]

    x
}

DropTip <- function(phy, tip, trim.internal = TRUE, subtree = FALSE, root.edge = 0,
                    rooted = is.rooted(phy)) {
# Copied from ape:::drop.tip; edited to avoid excessive calls to $, and to support single-taxon trees.
# Dropped support for branch lengths.
  if (!inherits(phy, "phylo"))
      stop('object "phy" is not of class "phylo"')
  if (!length(tip)) return(phy)
  phy.edge <- phy$edge
  phy.tip <- phy$tip.label
  Ntip <- length(phy.tip)
  if (is.character(tip)) tip <- which(phy.tip %in% tip)
  ntip.to.drop <- length(tip)
  if (!ntip.to.drop) return(phy)
  if (ntip.to.drop + 1 == Ntip) 
    return(single.taxon.tree(phy.tip[setdiff(1:Ntip, tip)]))
  if (any(tip > Ntip))
    warning("Some tip numbers were higher than the number of tips")
  if (!rooted && subtree) {
    phy <- root(phy, (1:Ntip)[-tip][1])
    root.edge <- 0
  }

  phy <- reorder(phy)
  NEWROOT <- ROOT <- Ntip + 1
  Nnode <- phy$Nnode
  Nedge <- dim(phy.edge)[1]
  if (subtree) {
    trim.internal <- TRUE
    tr <- reorder(phy, "pruningwise")
    tr.edge <- tr$edge
    N <- .C("node_depth", as.integer(Ntip), as.integer(Nnode),
            as.integer(tr.edge[, 1]), as.integer(tr.edge[, 2]),
            as.integer(Nedge), double(Ntip + Nnode),
            DUP = FALSE, PACKAGE = "ape")[[6]]
  }
  edge1 <- phy.edge[, 1] # local copies
  edge2 <- phy.edge[, 2] #
  keep <- !logical(Nedge)
  keep[match(tip, edge2)] <- FALSE # Delete the terminal edges given by 'tip'
  if (trim.internal) {
    ints <- edge2 > Ntip
    ## delete the internal edges that no longer have
    ## descendants (ie, they are in the 2nd col of `edge' but
    ## not in the 1st one)
    repeat {
      sel <- !(edge2 %in% edge1[keep]) & ints & keep
      if (!any(sel)) break
      keep[sel] <- FALSE
    }
    if (subtree) {
      ## keep the subtending edge(s):
      subt <- edge1 %in% edge1[keep] & edge1 %in% edge1[!keep]
      keep[subt] <- TRUE
    }
  }

  if (!root.edge) phy$root.edge <- NULL

  ## drop the edges
  phy.edge <- phy.edge[keep, ]

  ## find the new terminal edges (works whatever 'subtree' and 'trim.internal'):
  TERMS <- !(phy.edge[, 2] %in% phy.edge[, 1])

  ## get the old No. of the nodes and tips that become tips:
  oldNo.ofNewTips <- phy.edge[TERMS, 2]

  ## in case some tips are dropped but kept because of 'subtree = TRUE':
  if (subtree) {
    i <- which(tip %in% oldNo.ofNewTips)
    if (length(i)) {
      phy$tip.label[tip[i]] <- "[1_tip]"
      tip <- tip[-i]
    }
  }

  n <- length(oldNo.ofNewTips) # the new number of tips in the tree

  ## the tips may not be sorted in increasing order in the
  ## 2nd col of edge, so no need to reorder $tip.label
  phy.edge[TERMS, 2] <- rank(phy.edge[TERMS, 2])
  phy$tip.label <- phy$tip.label[-tip]

  ## make new tip labels if necessary:
  if (subtree || !trim.internal) {
      ## get the numbers of the nodes that become tips:
      node2tip <- oldNo.ofNewTips[oldNo.ofNewTips > Ntip]
      new.tip.label <- if (subtree) {
          paste("[", N[node2tip], "_tips]", sep = "")
      } else {
          if (is.null(phy$node.label)) rep("NA", length(node2tip))
          else phy$node.label[node2tip - Ntip]
      }
#        if (!is.null(phy$node.label))
#            phy$node.label <- phy$node.label[-(node2tip - Ntip)]
      phy$tip.label <- c(phy$tip.label, new.tip.label)
  }

  phy$Nnode <- dim(phy.edge)[1] - n + 1L # update phy$Nnode

  ## The block below renumbers the nodes so that they conform
  ## to the "phylo" format, same as in root()
  newNb <- integer(Ntip + Nnode)
  newNb[NEWROOT] <- n + 1L
  sndcol <- phy.edge[, 2] > n
  ## executed from right to left, so newNb is modified before phy.edge:
  phy.edge[sndcol, 2] <- newNb[phy.edge[sndcol, 2]] <-
      (n + 2):(n + phy$Nnode)
  phy.edge[, 1] <- newNb[phy.edge[, 1]]
  phy$edge <- phy.edge
  storage.mode(phy$edge) <- "integer"
  if (!is.null(phy$node.label)) # update node.label if needed
      phy$node.label <- phy$node.label[which(newNb > 0) - Ntip]
  collapse.singles.fast(phy)
}

RandomTree <- function (data, br=NULL) {
  tips <- switch(class(data),
    'phylo' = data$tip.label,
    'phyDat' = names(data),
    'fitchDat' = names(data),
    stop('Data class not supported')
  )
  n.tips <- length(tips)
  return(rtree(n.tips, tip.label=tips, br=br))
}

FitchInfoFast <- function (tree, data) {
    # Data
  if (class(data) == 'phyDat') data <- PrepareDataFitch(data)
  if (class(data) != 'fitchDat') stop('Invalid data type; try FitchInfoFast(tree, data <- 
                                      PrepareDataFitch(valid.phyDat.object)).')
  at <- attributes(data)
  n.char  <- at$nr # strictly, transformation series patterns; these'll be upweighted later
  weight <- at$weight
  info <- at$info.amounts
  if (is.null(at$order) || at$order == "cladewise") tree <- reorder(tree, "postorder")
  tree.edge <- tree$edge
  parent <- tree.edge[,1]
  child <- tree.edge[,2]
  tip.label <- tree$tip.label
  n.edge <- length(parent)
  max.node <- parent[1] #max(parent)
  n.tip <- length(tip.label)
  n.node <- max.node - n.tip
  inapp <- at$inapp.level
  parent.of <- parent[match((n.tip + 2L):max.node, child )]
  allNodes <- (n.tip + 1L):max.node
  child.of <- child [c(match(allNodes, parent),
                       length(parent) + 1L - match(allNodes, rev(parent)))]
  fitch <- .Call("FITCH", data[, tree$tip.label], as.integer(n.char),
        as.integer(parent), as.integer(child), as.integer(n.edge),
        as.double(weight), as.integer(max.node), as.integer(n.tip))# , package='phangorn')
#
#  Future support for inapplicable data to be added here:
#  
#  nLevel <- length(at$level)
#  powers.of.2 <- 2L^c(0L:(nLevel - 1L))
#  inapp.level <- which(at$levels == "-")
#  applicable.tokens <- setdiff(powers.of.2, 2^(inapp.level - 1))
#  fitch <- .Call("FITCHINAPP", data[, tip.label], as.integer(n.char), as.integer(parent),
#                 as.integer(child), as.integer(parent.of), as.integer(child.of),
#                 as.integer(n.edge), as.integer(n.node), as.double(weight),
#                 as.integer(max.node), as.integer(n.tip), as.integer(inapp),
#                 PACKAGE='inapplicable') 

  steps <- fitch[[2]]
  # Return a negative rather than positive value because algorithms assume that 
  # smaller numbers are better
  return(-sum(info[(steps - 1) * n.char + seq_len(n.char)] * weight))
}


